# Multi-table relationships

This section shows how to use SeaORM to perform operations between the Fruits table and a new suppliers table.

Creating relationships between tables can be verbose when doing so using code. Luckily, SeaORM makes this easy. Define a table called `suppliers` in the `fruit_markets` database by taking the following steps:

1. Login to mysql database using username and password created in the `installation` part of this tutorial in the previous section and switch to fruit_markets database.

   ```sql
   # Execute 
   use fruit_markets;
   ```

2. Create a table `suppliers` that references the primary key `fruit_id` of table `fruits`. This will show the type of fruit the supplier supplies to the fruit markets.

   ```sql
   CREATE TABLE suppliers(
       supplier_id INT NOT NULL AUTO_INCREMENT,
       supplier_name VARCHAR(255) NOT NULL,
       fruit_id  INT NOT NULL,  
       PRIMARY KEY (supplier_id),
       CONSTRAINT fk_fruits
       FOREIGN KEY (fruit_id) 
       REFERENCES fruits(fruit_id)
           ON UPDATE CASCADE
           ON DELETE CASCADE
   ) ENGINE=INNODB;
   ```

3. Use `sea-orm-cli` to generate the `Entity`, `Model`, `Relationship` and `ActiveModel`.

   ```sh
   $ sea-orm-cli generate entity -o src/suppliers_table -t suppliers
   ```

   A new directory `suppliers_table` is created in the `src` directory containing serveral files with code generated by `sea-orm-cli`.

4. Modify the `src/suppliers_table/prelude.rs` file to export memorable names of the `Entity, ActiveModel` etc

   ```rust,noplayground,no_run
   - pub use super::suppliers::Entity as Suppliers;
   
   + pub use super::suppliers::{
   +     ActiveModel as SuppliersActiveModel, Column as SuppliersColumn, Entity as Suppliers,
   +     Model as SuppliersModel, PrimaryKey as SuppliersPrimaryKey, Relation as SuppliersRelation,
   + };
   
   ```

5. The `src/suppliers_table/suppliers.rs` contains errors indicating the `super::fruits` cannot be found in `supper`. This means the module is not exported properly. Fix this by importing the module:

   ```rust,noplayground,no_run
   //! SeaORM Entity. Generated by sea-orm-codegen 0.5.0
   
   use sea_orm::entity::prelude::*;
   
   #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
   #[sea_orm(table_name = "suppliers")]
   pub struct Model {
       #[sea_orm(primary_key)]
       pub supplier_id: i32,
       pub supplier_name: String,
       pub fruit_id: i32,
   }
   
   #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
   pub enum Relation {
       #[sea_orm(
   -       belongs_to = "super::fruits::Entity",
   +		belongs_to = "crate::Fruits",
           from = "Column::FruitId",
   -       to = "super::fruits::Column::FruitId",
   +       to = "crate::FruitsColumn::FruitId",
           on_update = "Cascade",
           on_delete = "Cascade"
       )]
       Fruits,
   }
   
   - impl Related<super::fruits::Entity> for Entity {
   + impl Related<crate::Fruits> for Entity {
       ...
      }
   
   impl ActiveModelBehavior for ActiveModel {}
   ```

   `sea-orm-cli` automatically generates code to bind the `suppliers` table `Model` to the primary key of the `fruits` table using `belongs_to = "crate::Fruits",` `to = "crate::FruitsColumn::FruitId"` and `impl Related<crate::Fruits> for Entity`. This corresponds to the SQL query part

   ```sql
    CONSTRAINT fk_fruits
       FOREIGN KEY (fruit_id) 
       REFERENCES fruits(fruit_id)
           ON UPDATE CASCADE
           ON DELETE CASCADE
   ```

6. Import the module to the `src/main.rs` file

   ```rust,noplayground,no_run
     mod fruits_table;
     use fruits_table::prelude::*;
   + mod suppliers_table;
   + use suppliers_table::prelude::*;
   
   // -- code snippet --
   
   // Convert this main function into async function
   #[async_std::main]
   async fn main() -> Result<()> {
       // -- code snippet --
   }
   ```

   

### Inserting Values into a Table with a Foreign Key

Insert many suppliers in the `supplies` table

```rust,no_run
// -- code snippet --

// Convert this main function into async function
#[async_std::main]
async fn main() -> Result<()> {
    // -- code snippet --
    
+   let supplier_01 = SuppliersActiveModel {
+       supplier_name: Set("John Doe".to_owned()),
+       fruit_id: Set(1_i32),
+       ..Default::default()
+   };

+   let supplier_02 = SuppliersActiveModel {
+       supplier_name: Set("Jane Doe".to_owned()),
+       fruit_id: Set(2_i32),
+       ..Default::default()
+   };

+   let supplier_03 = SuppliersActiveModel {
+       supplier_name: Set("Junior Doe".to_owned()),
+       fruit_id: Set(3_i32),
+       ..Default::default()
+   };

+   let supplier_insert_operation =
+       Suppliers::insert_many(vec![supplier_01, supplier_02, supplier_03])
+           .exec(&db)
+           .await;

+   println!("INSERTED MANY: {:?}", supplier_insert_operation?);

    
 	Ok(())   
}
```



Executing the program returns

```sh
$ INSERTED MANY: InsertResult { last_insert_id: 1 }
```

### SELECTing related tables

SeaORM makes it easy to fetch a table and it's related table referenced by its primary key using the `Entity::find().find_with_related(Other_Entity).all(DatabaseConnection)` chain of methods.

```rust,no_run
// --- Code Snippet ---
#[async_std::main]
async fn main() -> Result<()> {
    let env_database_url = include_str!("../.env").trim();
    let split_url: Vec<&str> = env_database_url.split("=").collect();
    let database_url = split_url[1];

    let db = Database::connect(database_url).await?;
    
    // -- Code snippet --
    

    let supplier_insert_operation =
        Suppliers::insert_many(vec![supplier_01, supplier_02, supplier_03])
            .exec(&db)
            .await;

    println!("INSERTED MANY: {:?}", supplier_insert_operation?);
    
+   let who_supplies = Suppliers::find().find_with_related(Fruits).all(&db).await?;
+   dbg!(&who_supplies);
    
    Ok(())
    
}
```

The operation returns a `Vec` which contains a tuple `(Model, Vec<Model>) ` which is `Vec<(Model, Vec<Model>)>`.  This means that the first `Model` , `tuple.0` is the `Model` that has relationships with the other `Model`s in the `tuple.1` index which is `Vec<Model>` .

Running the program, prints:

```sh
$
[
    (
        Model {
            supplier_id: 1,
            supplier_name: "John Doe",
            fruit_id: 1,
        },
        [
            Model {
                fruit_id: 1,
                name: "Apple",
                datetime_utc: 2022-01-26T09:16:43,
                unit_price: 2,
                sku: "FM2022AKB40",
            },
        ],
    ),
    (
        Model {
            supplier_id: 2,
            supplier_name: "Jane Doe",
            fruit_id: 2,
        },
        [
            Model {
                fruit_id: 2,
                name: "Banana",
                datetime_utc: 2022-01-26T09:16:43,
                unit_price: 2,
                sku: "FM2022AKB41",
            },
        ],
    ),
    (
        Model {
            supplier_id: 3,
            supplier_name: "Junior Doe",
            fruit_id: 3,
        },
        [
            Model {
                fruit_id: 3,
                name: "Pineapple",
                datetime_utc: 2022-01-26T09:16:43,
                unit_price: 10,
                sku: "FM2022AKB42",
            },
        ],
    ),
]
```

---

Thats SeaORM in action. A beginner friendly ORM, one codebase for MySQL, SQLite, MariaDB and PostgreSQL. What else could you ask for :)
